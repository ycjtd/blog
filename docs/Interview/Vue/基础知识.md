### 谈谈对 vue 的理解

- vue 是一套用于构建用户界面的渐进式框架，核心库只关心视图层
- 是一个声明式框架，更关注结果
- 收到 MVVM 模式启发，简化了映射关系
- 采用虚拟 DOM，比较新旧虚拟节点，找到变化再进行更新，提高性能

### 为什么 vue 组件中 data 必须是函数

- 根实例对象 data 可以是对象也可以是函数，因为根实例是单例，不会产生数据污染情况
- 组件实例对象 data 必须是函数，.vue 文件在使用的时候实际上会转换成一个 class，一个组件被复用多次的话，也会创建多个实例。本质上，这些实例用的都是同一个构造函数，如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件在不同的实例之间 data 不冲突，data 必须是一个函数

### v-show 和 v-if 的区别

区别

- v-show 隐藏则是为该元素添加 `css-display:none`，`dom`元素依旧还在，`v-if显示隐藏是将dom元素整个添加或删除`
- 编译过程：v-if 切换有一个局部编译/缺陷的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show 只是简单的基于 css 切换
- 编译条件：v-if 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染
- v-show 由 false 变为 true 的时候不会触发组件的生命周期
- v-if 由 false 变为 true 的时候，触发组件的 beforeCreate、create、beforeMount、mounted 钩子，由 true 变为 false 的时候触发组件的 beforeDestory、destory 方法
- 性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗

使用场景：

- v-if 和 v-show 都能控制 dom 元素在页面的显示
- v-if 和 v-show 开销更大的（直接操作 dom 节点增加与删除）
- 如果需要非常频繁的切换，则使用 v-show 较好
- 如果在运行时条件很少改变，则使用 v-if 较好

### 为什么 v-if 和 v-for 不建议一起使用

- 在 vue2 中，v-for 的优先级是高于 v-if 的，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕只渲染列表中一小部分元素，也得在每次重新渲染的时候遍历整个列表，这会比较浪费
- 在 vue3 中完全相反，v-if 的优先级是高于 v-for 的，所以 v-if 执行的时候，调用的变量还不存在，就会导致异常
- 如果一定要一起使用，可以把 v-if 移动到容器元素上，或者外面包一层 template

### 怎么获取 dom

使用 ref 和 refs

先给标签设置一个 ref 值，再通过`this.$refs.domName` 来获取

### vue 初始化页面闪动问题

在 vue 初始化之前，由于 div 是不归 vue 管的，所以写的代码在还没有解析的情况下会容易出现花屏现象，看到类似{{message}}的字样

可以在 css 里加

```js
[v-cloak] {
  disply:none
}
```

### ajax 请求应该放在 methods 还是 vuex 中

- 如果请求来的数据不是要被其它组件共用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 中
- 如果被其它地方复用，就放在 action 中，方便复用

### 对 SPA 页面的理解，优缺点

SPA，单页面应用，只在 web 页面初始化的时候加载相应的 HTML、CSS 和 JavaScript，一旦页面加载完成，SPA 不会因为用户的操作进行页面的重新加载或跳转，而是利用路由机制实现 HTML 内容的变换，UI 和用户的交互

优点：

- 用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
- 前后端职责分离，架构清晰，服务器压力小

缺点：

- 初次加载耗时多
- 前进后退路由难管理
- SEO 难度大

怎么解决

SSR + CSR 方式，首屏采用服务端渲染的方式，后续交互采用客户端渲染方式

### SPA 首屏加载慢怎么解决

什么叫首屏加载时间：浏览器从响应用户输入网站地址,到首屏内容渲染完成的时间,整个网页不一定要全部渲染完成,但是需要展示当前视窗需要的内容

加载慢的原因：

- 网络延时问题
- 资源文件体积过大
- 是否发生重复请求
- 加载脚本的时候，渲染内容堵塞

解决办法：

- 减小入口文件体积
- 静态资源本地缓存
- UI 框架按需加载
- 图片资源压缩
- 开启 GZip 压缩
- 使用 SSR

### 对 keep-alive 的理解

- `keep-alive` 是 `Vue` 内置的一个组件，**可以实现组件缓存**，当组件切换时不会对当前组件进行卸载。**一般结合路由和动态组件一起使用**，用于缓存组件
- 提供 `include` 和 `exclude` 属性，**允许组件有条件的进行缓存**。两者都支持字符串或正则表达式，`include` 表示只有名称匹配的组件会被缓存，`exclude` 表示任何名称匹配的组件都不会被缓存 ，其中 `exclude` 的优先级比 `include` 高
- 对应两个钩子函数 `activated` 和`deactivated` ，当组件被激活时，触发钩子函数 `activated`，当组件被移除时，触发钩子函数 `deactivated`
- `keep-alive` 的中还运用了 `LRU`(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰

### Vue.observable 有了解过吗?

让一个对象变成响应式数据,Vue 内部会用它来处理 data 函数返回的对象

使用场景: 实现非父子组件通信

### 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 检测差异

vue 设计的每一个组件一个 watcher，没有采用一个属性对应一个 watcher，这样会导致大量的 watcher 的产生而浪费内存，如果粒度过低也无法精准检测变化，所以采用 diff 算法+组件级 watcher

### Vue.mixin 使用场景和原理

- 在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 `Vue` 的 `mixin` 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 `mergeOptions` 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”；如果混入的数据和本身组件的数据冲突，会以组件的数据为准
- `mixin`有很多缺陷如：命名冲突、依赖问题、数据来源问题

### 对 MVVM 的理解

`MVVM`是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。`Model`层代表数据模型（也就是前端声明的静态数据或者是通过网络请求获取的数据），`View`代表 UI 组件（能看到的前端页面），`ViewModel`（其实就是 Vue/React 等前端框架）是`View`和`Model`层的桥梁，MVVM 模式不需要用户手动的去操作 DOM 元素，将数据绑定到 ViewModel 层上，会自动将数据渲染到页面中，视图变化会通知 ViewModel 层更新数据。

- `Model`: 代表数据模型，也可以在`Model`中定义数据修改和操作的业务逻辑。我们可以把`Model`称为数据层，因为它仅仅关注数据本身，不关心任何行为
- `View`: 用户操作界面。当`ViewModel`对`Model`进行更新的时候，会通过数据绑定更新到`View`
- `ViewModel`： 业务逻辑层，`View`需要什么数据，`ViewModel`要提供这个数据；`View`有某些操作，`ViewModel`就要响应这些操作，所以可以说它是`Model for View`.

### Vue 组件为什么只有一个根元素

1. `vue2`中组件确实只能有一个根，但`vue3`中组件已经可以多根节点了。
2. 之所以需要这样是因为`vdom`是一颗单根树形结构，`patch`方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个`vdom`
3. `vue3`中之所以可以写多个根节点，是因为引入了`Fragment`的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个`Fragment`节点，把多个根节点作为它的`children`。将来`patch`的时候，如果发现是一个`Fragment`节点，则直接遍历`children`创建或更新

### 函数式组件的优势和原理

1. 函数式组件需要在声明组件是指定 `functional:true`
2. 不需要实例化，所以没有`this`,`this`通过`render`函数的第二个参数`context`来代替
3. 没有生命周期钩子函数，不能使用计算属性，`watch`
4. 不能通过`$emit` 对外暴露事件，调用事件只能通过`context.listeners.click`的方式调用外部传入的事件
5. 因为函数式组件是没有实例化的，所以在外部通过`ref`去引用组件时，实际引用的是`HTMLElement`
6. 函数式组件的`props`可以不用显示声明，所以没有在`props`里面声明的属性都会被自动隐式解析为`prop`,而普通组件所有未声明的属性都解析到`$attrs`里面，并自动挂载到组件根元素上面(可以通过`inheritAttrs`属性禁止)

**优点**

1. 由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件
2. 函数式组件结构比较简单，代码结构更清晰

**使用场景：**

- 一个简单的展示组件，作为容器组件使用 比如 `router-view` 就是一个函数式组件
- “高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件

### 组件之间通信方式有哪些

- `props / $emit` **适用 父子组件通信**

  - 父组件向子组件传递数据是通过 `prop` 传递的，子组件传递数据给父组件是通过`$emit` 触发事件来做到的

- `ref` 与 `$parent / $children(vue3废弃)` **适用 父子组件通信**

  - `ref`：如果在普通的 `DOM` 元素上使用，引用指向的就是 `DOM` 元素；如果用在子组件上，引用就指向组件实例
  - `$parent / $children`：访问访问父组件的属性或方法 / 访问子组件的属性或方法

- `EventBus （$emit / $on）` **适用于 父子、隔代、兄弟组件通信**

  - 这种方法通过一个空的 `Vue` 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件

- `$attrs / $listeners(vue3废弃)` **适用于 隔代组件通信**

  - `$attrs`：包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 ( `class` 和 `style` 除外 )。当一个组件没有声明任何 `prop` 时，这里会包含所有父作用域的绑定 ( `class` 和 `style` 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `inheritAttrs` 选项一起使用，多余的属性不会被解析到标签上
  - `$listeners`：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件

- `provide / inject` **适用于 隔代组件通信**

  - 祖先组件中通过 `provider` 来提供变量，然后在子孙组件中通过 `inject` 来注入变量。 `provide / inject` API 主要解决了跨级组件间的通信问题，**不过它的使用场景，主要是子组件获取上级组件的状态**，跨级组件间建立了一种主动提供与依赖注入的关系

- `$root` **适用于 隔代组件通信** 访问根组件中的属性或方法，是根组件，不是父组件。`$root`只对根组件有用
- `Vuex` **适用于 父子、隔代、兄弟组件通信**

  - `Vuex` 是一个专为 `Vue.js` 应用程序开发的状态管理模式。每一个 `Vuex` 应用的核心就是 `store`（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( `state` )
  - `Vuex` 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
  - 改变 `store` 中的状态的唯一途径就是显式地提交 (`commit`) `mutation`。这样使得我们可以方便地跟踪每一个状态的变化。

**根据组件之间关系讨论组件通信最为清晰有效**

- 父子组件：`props`/`$emit`/`$parent`/`ref`
- 兄弟组件：`$parent`/`eventbus`/`vuex`
- 跨层级关系：`eventbus`/`vuex`/`provide+inject`/`$attrs + $listeners`/`$root`

### vue 如何扩展一个组件

1. 常见的组件扩展方法有：`mixins`，`slots`，`extends`等
2. 混入`mixins`是分发 `Vue` 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项、
3. 插槽主要用于`vue`组件中的内容分发，也可以用于组件扩展、
4. 组件选项中还有一个不太常用的选项`extends`，也可以起到扩展组件的目的

### 子组件可以直接改父组件的数据吗

1. 所有的 `prop` 都使得其父子之间形成了一个单向下行绑定：父级 `prop` 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。另外，每次父级组件发生变更时，子组件中所有的 `prop` 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 `prop`。如果你这样做了，`Vue` 会在浏览器控制台中发出警告
2. 实际开发过程中有两个场景会想要修改一个属性：**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。** 在这种情况下，最好定义一个本地的 `data`，并将这个 `prop` 用作其初始值：**这个 prop 以一种原始的值传入且需要进行转换。** 在这种情况下，最好使用这个 `prop` 的值来定义一个计算属性：
3. 实践中如果确实想要改变父组件属性应该`emit`一个事件让父组件去做这个变更。注意虽然我们不能直接修改一个传入的对象或者数组类型的`prop`，但是我们还是能够直接改内嵌的对象或属性

### 组件和插件有什么区别

**1. 组件是什么**

组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在 Vue 中每一个.vue 文件都可以视为一个组件

**组件的优势**

- 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现
- 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
- 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级

**2. 插件是什么**

插件通常用来为 `Vue` 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

- 添加全局方法或者属性。如: `vue-custom-element`
- 添加全局资源：指令/过滤器/过渡等。如 `vue-touch`
- 通过全局混入来添加一些组件选项。如`vue-router`
- 添加 `Vue` 实例方法，通过把它们添加到 `Vue.prototype` 上实现。
- 一个库，提供自己的 `API`，同时提供上面提到的一个或多个功能。如`vue-router`

**3. 两者的区别**

两者的区别主要表现在以下几个方面：

- 编写形式

  - 编写一个组件，可以有很多方式，我们最常见的就是 vue 单文件的这种格式，每一个`.vue`文件我们都可以看成是一个组件
  - `use`插件的实现应该暴露一个 `install` 方法。这个方法的第一个参数是 `Vue` 构造器，第二个参数是一个可选的选项对象

- 注册形式

  - vue 组件注册主要分为**全局注册**与**局部注册**
  - 插件的注册通过`Vue.use()`的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项

- 使用场景

  - 组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 `App.vue`
  - 件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身

简单来说，插件就是对 Vue 的功能的增强或补充

### .sync 和 v-model 的区别

- `.sync`修饰符可以实现父子组件之间的双向绑定，并且可以实现子组件同步修改父组件的值，相比较与`v-model`来说,`sync`修饰符就简单很多了
- 一个组件上可以有多个`.sync`修饰符

- 相同点

  - 都是语法糖，都可以实现父子组件中的数据的双向通信

- 区别点

  - 格式不同：`v-model="num"`, `:num.sync="num"`
  - `v-model`: `@input + value`
  - `:num.sync`: `@update:num`
  - `v-model`只能用一次；`.sync`可以有多个

### SSR 的理解

> `Vue.js` 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 `Vue` 组件，进行生成 `DOM` 和操作 `DOM`。然而，也可以将同一个组件渲染为服务端的 `HTML` 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

> `SSR`也就是服务端渲染，也就是将 `Vue` 在客户端把标签渲染成 `HTML` 的工作放在服务端完成，然后再把 `html` 直接返回给客户端

- **优点**：`SSR` 有着更好的 `SEO`、并且首屏加载速度更快

  - 因为 `SPA` 页面的内容是通过 `Ajax` 获取，而搜索引擎爬取工具并不会等待 `Ajax` 异步完成后再抓取页面内容，所以在 `SPA` 中是抓取不到页面通过 `Ajax`获取到的内容；而 `SSR` 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面
  - 更快的内容到达时间（首屏加载更快）： `SPA` 会等待所有 `Vue` 编译后的 `js` 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；`SSR` 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间

- **缺点**： 开发条件会受到限制，服务器端渲染只支持 `beforeCreate` 和 `created` 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 `Node.js` 的运行环境。服务器会有更大的负载需求

  - 在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 `server` 更加大量占用`CPU`资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略

**其基本实现原理**

- `app.js` 作为客户端与服务端的公用入口，导出 `Vue` 根实例，供客户端 `entry` 与服务端 `entry` 使用。客户端 `entry` 主要作用挂载到 `DOM` 上，服务端 `entry` 除了创建和返回实例，还进行路由匹配与数据预获取。
- `webpack` 为客服端打包一个 `Client Bundle` ，为服务端打包一个 `Server Bundle` 。
- 服务器接收请求时，会根据 `url`，加载相应组件，获取和解析异步数据，创建一个读取 `Server Bundle` 的 `BundleRenderer`，然后生成 `html` 发送给客户端。
- 客户端混合，客户端收到从服务端传来的 `DOM` 与自己的生成的 DOM 进行对比，把不相同的 `DOM` 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 `stroe` 里，这样，在客户端挂载到 `DOM` 之前，可以直接从 `store`里取数据。首屏的动态数据通过 `window.__INITIAL_STATE__`发送到客户端

> `Vue SSR` 的实现，主要就是把 `Vue` 的组件输出成一个完整 `HTML`, `vue-server-renderer` 就是干这事的

`Vue SSR`需要做的事多点（输出完整 HTML），除了`complier -> vnode`，还需如数据获取填充至 `HTML`、客户端混合（`hydration`）、缓存等等。相比于其他模板引擎（`ejs`, `jade` 等），最终要实现的目的是一样的，性能上可能要差点

**怎么理解 vue 的单向数据流**

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会**防止从子组件意外改变父级组件的状态**，从而导致你的应用的数据流向难以理解

### delete 和 Vue.delete 删除数组的区别

- `delete`只是被删除的元素变成了 `empty/undefined` 其他的元素的键值还是不变。
- `Vue.delete`直接删除了数组 改变了数组的键值。

### Vue Ref 的作用

- 获取`dom`元素`this.$refs.box`
- 获取子组件中的`data this.$refs.box.msg`
- 调用子组件中的方法`this.$refs.box.open()`

### vue-loader 是什么？有什么作用？

1. `vue-loader`是用于处理单文件组件（`SFC`，`Single-File Component`）的`webpack loader`
2. 因为有了`vue-loader`，我们就可以在项目中编写`SFC`格式的`Vue`组件，我们可以把代码分割为`<template>`、`<script>`和`<style>`，代码会异常清晰。结合其他`loader`我们还可以用`Pug`编写`<template>`，用`SASS`编写`<style>`，用`TS`编写`<script>`。我们的`<style>`还可以单独作用当前组件
3. `webpack`打包时，会以`loader`的方式调用`vue-loader`
4. `vue-loader`被执行时，它会对`SFC`中的每个语言块用单独的`loader`链处理。最后将这些单独的块装配成最终的组件模块

### 从 0 到 1 自己构架一个 vue 项目，有哪些步骤，哪些重要插件、目录结构怎么组织

1. 从`0`创建一个项目我大致会做以下事情：项目构建、引入必要插件、代码规范、提交规范、常用库和组件
2. 目前`vue3`项目我会用`vite`或者`create-vue`创建项目
3. 接下来引入必要插件：路由插件`vue-router`、状态管理`vuex/pinia`、`ui`库我比较喜欢`element-plu`s 和`antd-vue`、`http`工具我会选`axios`
4. 其他比较常用的库有`vueuse`，`nprogress`，图标可以使用`vite-svg-loader`
5. 下面是代码规范：结合`prettier`和`eslint`即可
6. 最后是提交规范，可以使用`husky`，`lint-staged`，`commitlint`
7. 目录结构我有如下习惯： `.vscode`：用来放项目中的 `vscode` 配置

- `plugins`：用来放 `vite` 插件的 `plugin` 配置
- `public`：用来放一些诸如 页头`icon` 之类的公共文件，会被打包到`dist`根目录下
- `src`：用来放项目代码文件
- `api`：用来放`http`的一些接口配置
- `assets`：用来放一些 `CSS` 之类的静态资源
- `components`：用来放项目通用组件
- `layout`：用来放项目的布局
- `router`：用来放项目的路由配置
- `store`：用来放状态管理`Pinia`的配置
- `utils`：用来放项目中的工具方法类
- `views`：用来放项目的页面文件
