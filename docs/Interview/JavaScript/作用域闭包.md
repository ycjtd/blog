### 什么是作用域？

作用域就是可访问变量的集合，做大的作用就是隔离变量，不同作用域下同名变量不会冲突

### 作用域的类型？

全局作用域、函数作用域和块级作用域

### 函数作用域

指的是声明在函数内部的变量，函数的作用域在函数**定义**的时候决定的

### 块作用域

块作用域由 `{}`包括，if 和 for 语句中的`{}`也属于块作用域

在块级作用域中，可以通过 let 和 const 声明变量，这个变量在块级作用域外无法被访问

### var let const 区别

var：没有块级作用域概念，可以跨块访问，会变量提升

let：只能在块作用域中访问，不能跨块访问，也不能跨函数访问，没有变量提升，不能重复声明

const：用来定义常量，声明时必须赋值，只能在块级作用域中访问，不能修改，没有变量提升，不能重复声明

### 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级的执行上下文的变量对象中查找，如果还没有找到，一直找到全局上下文的变量对象，也就是全局对象。这种由多个执行上下文的变量对象构成的链表就叫作用域链

### 闭包

有权访问另外一个函数作用域中的变量的函数，主要的就两点，一是是一个函数，二是能访问另外一个函数作用域中的变量

**闭包的特性**：

- 可以访问当前函数以外的变量
- 即使外部函数已经返回，闭包仍然能访问外部函数定义的变量
- 闭包可以更新外部变量的值

**使用闭包应该注意什么：**

- 内存泄露：闭包会捕获外部函数的变量，所以在闭包内部可以访问这些变量，但是需要注意的是闭包会保持对外部变量的引用，导致这些变量不会被销毁，可能导致内存泄露问题
- 变量命名冲突：当闭包内部和外部作用域中存在相同名称的变量的时候，闭包内部的变量会覆盖外部变量，所以需要避免变量命名冲突

**闭包的实现原理是什么**：

利用了作用域链的特性，在当前执行环境下访问某个变量的时候，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域

```js
// 原始题目
for (var i = 0; i < 5; i++) {
setTimeout(function () {
console.log(i); // 1s 后打印出 5 个 5
}, 1000);
}

// 输出是什么？为什么
输出是 5 5 5 5 5
在循环中，使用 var 声明了一个全局变量 i，使用 setTimeout 创建了 5 个定时器任务，
每个任务都在 1s 后执行
在每个 setTimeout 的回调函数中，尝试访问 i 的值，这个回调函数是在循环结束之后才会执行
在循环结束的时候，全局变量 i 为 5，所以输出是 5 5 5 5 5

// 怎么改成 1s 后，打印 0,1,2,3,4

// 方法 1 闭包
使用立即执行函数创建了闭包，将当前的 i 值传递给回调函数

for (var i = 0; i < 5; i++) {
(function (j) {
setTimeout(function timer() {
console.log(j);
}, 1000);
})(i);
}

// 方法 2
for (var i = 0; i < 5; i++) {
setTimeout(
function fn(i) {
console.log(i);
},
1000,
i
); // 第三个参数 i,将作为 fn 的参数
}

// 方法 3
使用 let 声明变量 i，具有块级作用域，而不是函数作用域，在每次迭代的时候都会创建一个新的变量 i，
而不是共享一个全局变量
当循环执行的时候，会在每次迭代中创建一个新的块级作用域，并在这个作用域内声明一个新的变量 i，
不会污染外部作用域，所以在每个回调函数中都能访问到正确的 i 值

for(let i = 1; i <= 5; i++){
setTimeout(function() {
console.log(i);
},0)
}
```
