作为浏览器脚本语言，JavaScript 的主要用途是和用户交互以及操作 DOM，所以只能是单线程，如果不是单线程，会带来很复杂的同步问题，比如一个线程在 DOM 节点上添加内容，另一个线程删除节点，此时浏览器不知道以那个为准。

同一个时间只能做一件事。所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着

所有任务可以分成两种，一种是宏任务，另一种是微任务

宏任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务 微任务指的是，不进入主线程、而进入"微任务队列"的任务

当前宏任务执行完后，会判断微任务列表中是否有任务。如果有，会把该微任务放到主线程中并执行，如果没有，就继续执行下一个宏任务

**宏任务 微任务**

宏任务：script 全部代码（同步代码也属于宏任务）、setTimeout、setInterval、setImmediate 等

微任务：Promsie、MutationObserver

**执行过程**

1）代码执行过程中，宏任务和微任务放在不同的任务队列中

2）当某个宏任务执行完后,会查看微任务队列是否有任务。如果有，执行微任务队列中的所有微任务(注意这里是执行所有的微任务)

3）微任务执行完成后，会读取宏任务队列中排在最前的第一个宏任务（注意宏任务是一个个取），执行该宏任务，如果执行过程中，遇到微任务，依次加入微任务队列

4）宏任务执行完成后，再次读取微任务队列里的任务，依次类推。

**async await 事件轮询执行时机**

async 隐式返回 Promise，会产生一个微任务

await 后面的代码是在微任务时执行

**event loop 和浏览器更新渲染时机**

1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即`宏任务 →  微任务  →  渲染更新`（先宏任务 再微任务，然后再渲染更新）

2）宏任务队列中，如果有大量任务等待执行时，将`dom的变动作为微任务，能更快的将变化呈现给用户`，这样就可以在这一次的事件轮询中更新 dom

**event loop 和 vue nextTick**

1） vue nextTick 的源码实现，优先级判断，总结就是`Promise > MutationObserver > setImmediate > setTimeout`

2）这里优先使用 Promise，因为根据 event loop 与浏览器更新渲染时机，使用微任务，本次 event loop 轮询就可以获取到更新的 dom

3）如果使用宏任务，要到下一次 event loop 中，才能获取到更新的 dom

**Node 中的 process.nextTick**

执行顺序早于微任务
